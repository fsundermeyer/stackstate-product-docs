ifdef::ss-ff-stackpacks2_enabled[]
= Ajouter des graphiques personnalisés aux composants
:revdate: 2025-07-10
:page-revdate: {revdate}
:description: SUSE Observability

== Vue d'ensemble

{stackstate-product-name} fournit déjà de nombreux graphiques métriques par défaut sur la plupart des types de composants qui représentent des ressources Kubernetes. Des tableaux métriques supplémentaires peuvent être ajoutés à n'importe quel ensemble de composants en cas de besoin. Deux options s'offrent à vous lorsque vous ajoutez des métriques à des composants :

. Les métriques sont déjà collectées par {stackstate-product-name} mais ne sont pas visualisées sur un composant, par défaut.
. Les données ne sont pas encore collectées par {stackstate-product-name} et ne sont donc pas encore disponibles.

Pour l'option 1, les étapes ci-dessous vous expliquent comment créer un lien métrique qui configurera {stackstate-product-name} pour ajouter une métrique spécifique à un ensemble spécifique de composants.

Pour l'option 2, assurez-vous que les métriques sont disponibles dans {stackstate-product-name} en les envoyant à {stackstate-product-name} à l'aide du xref:/use/metrics/k8s-prometheus-remote-write.adoc[protocole d'écriture à distance Prometheus]. Poursuivez en ajoutant des graphiques pour les mesures aux composants UNIQUEMENT après vous être assuré que les mesures sont disponibles.

== Création d'une liaison métrique

. <<_create_an_outline_of_the_metric_binding,Créer une ébauche de la liaison métrique>>
. <<_select_the_components_to_bind_to,Sélectionner les composants à lier>>
. <<_write_the_promql_query,Rédiger la requête PromQL pour la métrique souhaitée>>
. <<_bind_the_correct_time_series_to_each_component,Lier la bonne série temporelle à chaque composant>>

Par exemple, les étapes permettront d'ajouter une métrique pour `Replica counts` des déploiements Kubernetes. Cette liaison métrique existe déjà dans {stackstate-product-name}, par défaut.

=== Créer une ébauche de la liaison métrique

Ouvrez le fichier YAML `metricbindings.yaml` dans votre éditeur de code préféré pour le modifier tout au long de ce guide.  Vous pouvez utiliser le CLI pour xref:/setup/custom-integrations/develop.adoc#_test_your_stackpack[tester votre StackPack].

----
- _type: MetricBinding
  chartType: line
  enabled: true
  identifier: urn:stackpack:my-stackpack:shared:metric-binding:node-memory-bytes-available-scheduling
  layout:
    metricPerspective:
      section: Resources
      tab: Kubernetes Node
  name: Memory available for scheduling (Custom)
  priority: medium
  queries:
  - alias: ${cluster_name} - ${node}
    expression: max_over_time(kubernetes_state_node_memory_allocatable{cluster_name="${tags.cluster-name}", node="${name}"}[${__interval}])
  scope: (label = "stackpack:kubernetes" and type = "node")
  unit: bytes(IEC)
----

La section relative aux questions et au champ d'application sera complétée dans les étapes suivantes. Notez que l'unité utilisée est `short`, qui rendra simplement une valeur numérique. Si vous n'êtes pas encore sûr de l'unité de mesure, vous pouvez la laisser ouverte et décider de l'unité correcte lors de la rédaction de la requête PromQL.

=== Sélectionner les composants à lier

Enregistrez une vue de la xref:/use/views/k8s-topology-perspective.adoc[perspective Topologie] et utilisez les filtres (Filtres -> Topologie -> Switch to STQL) pour interroger les composants qui doivent afficher la nouvelle métrique. Les champs les plus courants pour sélectionner la topologie pour les liaisons métriques sont `type` pour le type de composant et `label` pour la sélection de toutes les étiquettes. Par exemple pour les déploiements :

----
type = "deployment" and label = "stackpack:kubernetes"
----

Le filtre de type sélectionne tous les déploiements, tandis que le filtre d'étiquette sélectionne uniquement les composants créés par le stackpack Kubernetes (le nom de l'étiquette est `stackpack` et la valeur de l'étiquette est `kubernetes`). Ce dernier peut également être omis pour obtenir le même résultat.  Tous les xref:/develop/reference/k8sTs-stql_reference.adoc#_component_filters[filtres des composants des requêtes STQL] peuvent être utilisés pour le filtrage.

Passez en mode avancé pour copier la requête topologique résultante et la placer dans le champ `scope` de la liaison métrique.

[NOTE]
====
Les liaisons métriques ne prennent en charge que les filtres de requête. Les fonctions d'interrogation telles que `withNeighborsOf` ne sont pas prises en charge et ne peuvent pas être utilisées.
====


=== Écrire la requête PromQL

Accédez à l'xref:/use/metrics/k8sTs-explore-metrics.adoc[explorateur de métriques] de votre instance {stackstate-product-name}, http://your-instance/#/metrics,, et utilisez-le pour rechercher la métrique qui vous intéresse. L'explorateur dispose d'une auto-complétion pour les métriques, les étiquettes, les valeurs des étiquettes, mais aussi les fonctions PromQL et les opérateurs pour vous aider. Commencez par une courte période, par exemple une heure, pour obtenir les meilleurs résultats.

Pour le nombre total de répliques, utilisez la métrique `kubernetes_state_deployment_replicas`. Pour afficher les graphiques de métriques des données de la série temporelle, étendez la requête pour faire une agrégation en utilisant le paramètre `${__interval}`:

----
max_over_time(kubernetes_state_deployment_replicas[${__interval}])
----

Dans ce cas précis, utilisez `max_over_time` pour vous assurer que le graphique affiche toujours le nombre le plus élevé de répliques à un moment donné. Pour les périodes plus longues, une courte chute des répliques n'est pas montrée. Pour mettre l'accent sur le plus petit nombre de répliques, utilisez plutôt `min_over_time`.

Copiez la requête dans la propriété `expression` de la première entrée du champ `queries` de la liaison métrique. Utilisez `Total replicas` comme alias. pour qu'il apparaisse dans la légende du graphique.

[NOTE]
====
Dans {stackstate-product-name}, la taille du graphique métrique détermine automatiquement la granularité de la métrique affichée dans le graphique. Les requêtes PromQL peuvent être ajustées afin d'optimiser l'utilisation de ce comportement et d'obtenir un graphique représentatif de la mesure. L'xref:/setup/custom-integrations/metric-bindings/writing-promql.adoc[écriture de PromQL pour les graphiques] explique cela en détail.
====


=== Lier la bonne série temporelle à chaque composant

La liaison métrique avec tous les champs remplis :

----
_type: MetricBinding
chartType: line
enabled: true
tags: {}
unit: short
name: Replica counts
priority: MEDIUM
identifier: urn:stackpack:my-stackpack:metric-binding:my-deployment-replica-counts
queries:
  - expression: max_over_time(kubernetes_state_deployment_replicas[${__interval}])
    alias: Total replicas
scope: type = "deployment" and label = "stackpack:kubernetes"
----

La création d'un réplica dans {stackstate-product-name} et l'affichage du graphique "Replica count" sur un composant de déploiement donnent un résultat inattendu. Le graphique montre le nombre de répliques pour tous les déploiements. Logiquement, on ne devrait s'attendre qu'à une seule série temporelle : le nombre de répliques pour ce déploiement spécifique.

image::k8s/k8s-replica-counts-without-binding.png[Le tableau incorrect pour un déploiement unique, it shows the replica count for all deployments]

Pour résoudre ce problème, la requête PromQL doit être spécifique à un composant et utiliser des informations provenant de ce composant. Filtrez sur un nombre suffisant d'étiquettes métriques pour ne sélectionner que les séries temporelles spécifiques pour le composant. Il s'agit de "lier" la bonne série temporelle au composant. Pour ceux qui ont l'habitude de créer des tableaux de bord Grafana, cela ressemble à un tableau de bord avec des paramètres qui sont utilisés dans les requêtes sur le tableau de bord. Modifions la requête dans la liaison métrique :

----
max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
----

image::k8s/k8s-replica-counts-with-binding.png[Après avoir ajouté les filtres paramétrés, le graphique obtenu ressemble à ce qui est attendu, only one time series for this component]

La requête PromQL filtre désormais sur trois étiquettes, `cluster_name`, `namespace` et `deployment`. Au lieu de spécifier une valeur réelle pour ces étiquettes, une référence variable aux champs du composant est utilisée. Dans ce cas, les étiquettes `cluster-name` et `namespace` sont utilisées, référencées à l'aide de `${tags.cluster-name}` et `${tags.namespace}`. En outre, le nom du composant est référencé par `${name}`.

Les références de variables prises en charge sont les suivantes :

* Toute étiquette de composant, à l'aide de `${tags.<label-name>}`
* Le nom du composant, en utilisant `${name}`

image::k8s/k8s-carts-highlights.png[La page de mise en évidence du composant qui montre les étiquettes et le nom du composant (tous deux surlignés en rouge).]

[NOTE]
====
Le nom du cluster, l'espace de noms et une combinaison du type et du nom du composant sont généralement suffisants pour sélectionner les métriques d'un composant spécifique de Kubernetes. Ces étiquettes, ou des étiquettes similaires, sont généralement disponibles sur la plupart des paramètres et des composants.
====


== Avancé

=== Plus d'une série temporelle dans un graphique

[NOTE]
====
Il n'y a qu'une seule unité pour une reliure métrique (elle est représentée sur l'axe des ordonnées du graphique). Par conséquent, vous ne devez combiner que les requêtes qui produisent des séries temporelles avec la même unité dans une seule liaison métrique. Il est parfois possible de convertir l'unité. Par exemple, l'utilisation de l'unité centrale peut être indiquée en milli-cores ou en cœurs. Les milli-cores peuvent être convertis en cœurs en les multipliant par 1000, comme dans le cas suivant : `(<original-query>) * 1000`.
====


Il y a deux façons d'obtenir plus d'une série temporelle dans une seule liaison métrique et donc dans un seul graphique :

. Écrire une requête PromQL qui renvoie plusieurs séries temporelles pour un seul composant.
. Ajouter des requêtes PromQL à la liaison métrique

Pour la première option, un exemple est donné dans la xref:/setup/custom-integrations/metric-bindings/index.adoc#_using_metric_labels_in_aliases[section suivante]. La deuxième option peut s'avérer utile pour comparer des mesures connexes. Quelques cas d'utilisation typiques :

* Comparaison entre le nombre total de répliques et les répliques souhaitées et disponibles
* Utilisation des ressources : limites, demandes et utilisation dans un seul graphique

Pour ajouter d'autres requêtes à une liaison métrique, il suffit de répéter les xref:/setup/custom-integrations/metric-bindings/index.adoc#_steps[étapes] 3 et 4 et d'ajouter la requête en tant qu'entrée supplémentaire dans la liste des requêtes. En ce qui concerne le nombre de répliques de déploiement, plusieurs mesures connexes peuvent être incluses dans le même graphique :

----
- _type: MetricBinding
  chartType: line
  enabled: true
  tags: {}
  unit: short
  name: Replica counts
  priority: MEDIUM
  identifier: urn:stackpack:my-stackpack:metric-binding:my-deployment-replica-counts
  queries:
    - expression: max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
      alias: Total replicas
    - expression: max_over_time(kubernetes_state_deployment_replicas_available{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Available - ${cluster_name} - ${namespace} - ${deployment}
    - expression: max_over_time(kubernetes_state_deployment_replicas_unavailable{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Unavailable - ${cluster_name} - ${namespace} - ${deployment}
    - expression: min_over_time(kubernetes_state_deployment_replicas_desired{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Desired - ${cluster_name} - ${namespace} - ${deployment}
  scope: type = "deployment" and label = "stackpack:kubernetes"
----

image::k8s/k8s-replica-counts-multiple-timeseries.png[Liaison de métriques avec plusieurs métriques]

=== Utilisation d'étiquettes métriques dans les alias

Lorsqu'une requête unique renvoie plusieurs séries temporelles par composant, cela se traduit par plusieurs lignes dans le graphique. Mais dans la légende, ils utiliseront tous le même alias. Pour pouvoir voir la différence entre les différentes séries temporelles, l'alias peut inclure des références aux étiquettes métriques à l'aide de la syntaxe `${label}`. Par exemple, voici une liaison de métrique pour la métrique "Container restarts" sur un pod, notez qu'un pod peut avoir plusieurs conteneurs :

----
type: MetricBinding
chartType: line
enabled: true
id: -1
identifier: urn:stackpack:my-stackpack:metric-binding:my-pod-restart-count
name: Container restarts
priority: MEDIUM
queries:
- alias: Restarts - ${container}
  expression: max by (cluster_name, namespace, pod_name, container) (kubernetes_state_container_restarts{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", pod_name="${name}"})
scope: (label = "stackpack:kubernetes" and type = "pod")
unit: short
----

Notez que `alias` fait référence à l'étiquette `container` de la métrique. Assurez-vous que l'étiquette est présente dans le résultat de la requête. Si l'étiquette n'est pas présente, le site `${container}` sera affiché en tant que texte littéral pour faciliter le dépannage.

=== Modèles

Chaque composant peut être associé à diverses technologies ou protocoles tels que les k8, les réseaux, les environnements d'exécution (par exemple, JVM), les protocoles (HTTP, AMQP), etc.
Par conséquent, une multitude de mesures différentes peuvent être affichées pour chaque composant. Pour une meilleure lisibilité, {stackstate-product-name} peut organiser ces graphiques sous forme d'onglets et de sections.
Pour afficher un graphique (`MetricBinding`) dans un onglet ou une section spécifique, vous devez configurer la propriété de mise en page.
Tout MetricsBinding dont la présentation n'est pas spécifiée sera affiché dans un onglet et une section nommés `Other`.

Voici un exemple de configuration :

endif::ss-ff-stackpacks2_enabled[]
