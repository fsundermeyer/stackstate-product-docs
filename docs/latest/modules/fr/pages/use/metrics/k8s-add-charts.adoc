= Ajouter des graphiques personnalisés aux composants
:revdate: 2025-07-10
:page-revdate: {revdate}
:description: SUSE Observability

== Vue d'ensemble

SUSE Observability fournit déjà de nombreux graphiques de métriques par défaut sur la plupart des types de composants qui représentent des ressources Kubernetes. Des tableaux métriques supplémentaires peuvent être ajoutés à n'importe quel ensemble de composants en cas de besoin. Lors de l'ajout de métriques aux composants, deux options sont possibles :

. Les mesures sont déjà collectées par SUSE Observability mais ne sont pas visualisées par défaut sur un composant.
. Les mesures ne sont pas encore collectées par SUSE Observability et ne sont donc pas encore disponibles.

Pour l'option 1, les étapes ci-dessous vous expliquent comment créer une liaison métrique qui configurera SUSE Observability pour ajouter une métrique spécifique à un ensemble spécifique de composants.

Dans le cas de l'option 2, il faut d'abord s'assurer que les métriques sont disponibles dans SUSE Observability, en les envoyant à SUSE Observability à l'aide du xref:/use/metrics/k8s-prometheus-remote-write.adoc[protocole d'écriture à distance Prometheus]. Ce n'est qu'ensuite qu'il faut continuer à ajouter des graphiques pour les métriques aux composants.

== Étapes

Étapes de la création d'une liaison métrique :

. <<_write_the_outline_of_the_metric_binding,Rédiger le plan de la reliure métrique>>
. <<_write_the_topology_query,Écrire la requête topologique (STQL) pour sélectionner les composants>>
. <<_write_the_promql_query,Rédiger la requête PromQL pour la métrique souhaitée>>
. <<_bind_the_correct_time_series_to_each_component,Lier la bonne série temporelle à chaque composant>>
. <<_create_or_update_the_metric_binding_in_suse_observability,Créer ou mettre à jour la liaison métrique dans SUSE Observability>>

A titre d'exemple, les étapes ajouteront une métrique pour `Replica counts` des déploiements Kubernetes. Ce n'est qu'un exemple, cette liaison métrique existe déjà par défaut dans SUSE Observability.

== Rédiger le plan de la reliure métrique

Créez un nouveau fichier YAML appelé `metric-bindings.yaml` et ajoutez-y ce modèle YAML pour créer votre propre liaison métrique. Ouvrez-le dans votre éditeur de code favori pour le modifier tout au long de ce guide. A la fin, le CLI de SUSE Observability sera utilisé pour créer et mettre à jour les liaisons métriques dans SUSE Observability.

----
nodes:
- _type: MetricBinding
  chartType: line
  enabled: true
  tags: {}
  unit:
  name:
  description:
  priority:
  identifier: urn:custom:metric-binding:...
  queries:
    - expression:
      alias:
  scope:
  layout:
    metricPerspective:
      tab:
      section:
      weight:
    componentSummary:
      weight:
----

Les champs de ce modèle sont les suivants :

* `_type`: SUSE Observability doit savoir qu'il s'agit d'une liaison métrique, la valeur doit donc toujours être `MetricBinding`
* `chartType`: SUSE Observability prendra en charge différents types de graphiques (`line`, `bar`, etc.). Actuellement, seul `line` est pris en charge.
* `enabled`: Définir à `false` pour conserver la liaison métrique mais ne pas l'afficher aux utilisateurs
* `tags`: Sera utilisé pour organiser les mesures dans l'interface utilisateur, peut être laissé vide en utilisant `{}`
* `unit`: L'unité des valeurs de la série temporelle renvoyée par la ou les requêtes, utilisée pour représenter l'axe Y du graphique. Voir la référence des xref:/develop/reference/k8sTs-chart-units.adoc[unités prises en charge] pour toutes les unités.
* `name`: Nom de la liaison métrique
* `description`: Description facultative, affichée au dessus du nom
* `priority`: [Déclassé] L'un de `HIGH`, `MEDIUM`, ou `LOW`. Ordre de tri principal pour les métriques d'un composant (dans l'ordre où elles sont mentionnées ici), l'ordre de tri secondaire est le `name`.
* `identifier`: Un URN (universal resource identifier), utilisé comme identifiant unique de la liaison métrique. Il doit commencer par `urn:custom:metric-binding:`, le reste est libre de format tant qu'il est unique parmi toutes les liaisons métriques.
* `queries`: Une liste de requêtes à afficher dans le graphique pour la liaison métrique (voir aussi les sections suivantes)
* `scope`: L'étendue de la topologie de la liaison métrique, une requête topologique qui sélectionne les composants sur lesquels cette liaison métrique sera affichée.
* `layout`: Comment regrouper les graphiques dans différentes perspectives, par exemple dans la xref:/use/views/k8s-metrics-perspective.adoc[perspective des métriques]?

Remplir d'abord toutes les parties déjà connues (en prenant pour exemple la réplique de déploiement).

----
_type: MetricBinding
chartType: line
enabled: true
tags: {}
unit: short
name: Replica counts
priority: MEDIUM
identifier: urn:custom:metric-binding:my-deployment-replica-counts
queries:
  - expression:
    alias:
scope:
----

La section relative aux questions et au champ d'application sera complétée dans les étapes suivantes. Notez que l'unité utilisée est `short`, qui rendra simplement une valeur numérique. Si vous n'êtes pas encore sûr de l'unité de mesure, vous pouvez la laisser ouverte et décider de l'unité correcte lors de la rédaction de la requête PromQL.

== Rédiger la requête topologique

Utilisez la vue Exploration de la xref:/use/views/k8s-topology-perspective.adoc[perspective Topologie], http://your-instance/#/views/explore, et sélectionnez les composants qui doivent afficher la nouvelle métrique. Les vues de base et avancée peuvent être utilisées pour effectuer la sélection. Les champs les plus courants pour sélectionner la topologie pour les liaisons métriques sont `type` pour le type de composant et `label` pour la sélection de toutes les étiquettes. Par exemple pour les déploiements :

----
type = "deployment" and label = "stackpack:kubernetes"
----

Le filtre de type sélectionne tous les déploiements, tandis que le filtre d'étiquette sélectionne uniquement les composants créés par le stackpack Kubernetes (le nom de l'étiquette est `stackpack` et la valeur de l'étiquette est `kubernetes`). Ce dernier peut également être omis pour obtenir le même résultat.

Passez en mode avancé pour copier la requête topologique résultante et la placer dans le champ `scope` de la liaison métrique.

[NOTE]
====
Les liaisons métriques ne prennent en charge que les filtres de requête, les fonctions de requête telles que `withNeighborsOf` ne sont pas prises en charge et ne peuvent pas être utilisées.
====


== Écrire la requête PromQL

Accédez à l'xref:/use/metrics/k8sTs-explore-metrics.adoc[explorateur de métriques] de votre instance SUSE Observability, http://your-instance/#/metrics,, et utilisez-le pour rechercher la métrique qui vous intéresse. L'explorateur dispose d'une auto-complétion pour les métriques, les étiquettes, les valeurs des étiquettes, mais aussi les fonctions PromQL et les opérateurs pour vous aider. Commencez par une courte période, par exemple une heure, pour obtenir les meilleurs résultats.

Pour le nombre total de répliques, utilisez la métrique `kubernetes_state_deployment_replicas`. Pour que les graphiques affichés pour cette mesure soient représentatifs des données de la série temporelle, étendez la requête pour effectuer une agrégation à l'aide du paramètre `${__interval}`:

----
max_over_time(kubernetes_state_deployment_replicas[${__interval}])
----

Dans ce cas précis, utilisez `max_over_time` pour vous assurer que le graphique affiche toujours le nombre le plus élevé de répliques à un moment donné. Pour les périodes plus longues, cela signifie qu'une courte baisse du nombre de répliques ne sera pas affichée. Pour mettre l'accent sur le nombre le plus bas de répliques, utilisez plutôt `min_over_time`.

Copiez la requête dans la propriété `expression` de la première entrée du champ `queries` de la liaison métrique. Utilisez `Total replicas` comme alias. Il s'agit du nom qui apparaîtra dans la légende du graphique.

[NOTE]
====
Dans SUSE Observability, la taille du diagramme de métriques détermine automatiquement la granularité de la métrique affichée dans le diagramme. Les requêtes PromQL peuvent être ajustées afin d'optimiser l'utilisation de ce comportement et d'obtenir un graphique représentatif de la mesure. L'xref:/use/metrics/k8s-writing-promql-for-charts.adoc[écriture de PromQL pour les graphiques] explique cela en détail.
====


== Lier la bonne série temporelle à chaque composant

La liaison métrique avec tous les champs remplis :

----
_type: MetricBinding
chartType: line
enabled: true
tags: {}
unit: short
name: Replica counts
priority: MEDIUM
identifier: urn:custom:metric-binding:my-deployment-replica-counts
queries:
  - expression: max_over_time(kubernetes_state_deployment_replicas[${__interval}])
    alias: Total replicas
scope: type = "deployment" and label = "stackpack:kubernetes"
----

La création d'un réplica dans SUSE Observability et l'affichage du graphique "Replica count" sur un composant de déploiement donnent un résultat inattendu. Le graphique montre le nombre de répliques pour tous les déploiements. Logiquement, on ne devrait s'attendre qu'à une seule série temporelle : le nombre de répliques pour ce déploiement spécifique.

image::k8s/k8s-replica-counts-without-binding.png[Le tableau incorrect pour un déploiement unique, it shows the replica count for all deployments]

Pour résoudre ce problème, la requête PromQL doit être spécifique à un composant et utiliser des informations provenant de ce composant. Filtrez sur un nombre suffisant d'étiquettes métriques pour ne sélectionner que les séries temporelles spécifiques pour le composant. Il s'agit de "lier" la bonne série temporelle au composant. Pour ceux qui ont l'habitude de créer des tableaux de bord Grafana, cela ressemble à un tableau de bord avec des paramètres qui sont utilisés dans les requêtes sur le tableau de bord. Modifions la requête dans la liaison métrique :

----
max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
----

image::k8s/k8s-replica-counts-with-binding.png[Après avoir ajouté les filtres paramétrés, le graphique obtenu ressemble à ce qui est attendu, only 1 time series for this component]

La requête PromQL filtre maintenant sur 3 étiquettes, `cluster_name`, `namespace` et `deployment`. Au lieu de spécifier une valeur réelle pour ces étiquettes, une référence variable aux champs du composant est utilisée. Dans ce cas, les étiquettes `cluster-name` et `namespace` sont utilisées, référencées à l'aide de `${tags.cluster-name}` et `${tags.namespace}`. En outre, le nom du composant est référencé par `${name}`.

Les références de variables prises en charge sont les suivantes :

* Toute étiquette de composant, à l'aide de `${tags.<label-name>}`
* Le nom du composant, en utilisant `${name}`

image::k8s/k8s-carts-highlights.png[La page de mise en évidence du composant qui montre les étiquettes et le nom du composant (tous deux surlignés en rouge).]

[NOTE]
====
Le nom du cluster, l'espace de noms et une combinaison du type et du nom du composant sont généralement suffisants pour sélectionner les métriques d'un composant spécifique de Kubernetes. Ces étiquettes, ou des étiquettes similaires, sont généralement disponibles sur la plupart des paramètres et des composants.
====


== Créer ou mettre à jour la liaison métrique dans SUSE Observability

Utilisez l'interface de commande de SUSE Observability pour créer la liaison métrique dans SUSE Observability. Assurez-vous que le site `metric-bindings.yaml` est sauvegardé et qu'il ressemble à ceci :

----
nodes:
- _type: MetricBinding
  chartType: line
  enabled: true
  tags: {}
  unit: short
  name: Replica counts
  priority: MEDIUM
  identifier: urn:custom:metric-binding:my-deployment-replica-counts
  queries:
    - expression: max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
      alias: Total replicas
  scope: type = "deployment" and label = "stackpack:kubernetes"
----

Utilisez l'xref:/setup/cli/cli-sts.adoc[interface de commande SUSE Observability] pour créer la liaison métrique :

[,bash]
----
sts settings apply -f metric-bindings.yaml
----

Vérifiez les résultats dans SUSE Observability en ouvrant la perspective des métriques pour un déploiement. Si vous n'êtes pas satisfait du résultat, il vous suffit de modifier le binding métrique dans le fichier YAML et d'exécuter à nouveau la commande pour le mettre à jour. La liste des nœuds permet d'ajouter de nombreuses liaisons métriques. Il suffit d'ajouter une autre entrée de liaison métrique au tableau YAML en suivant les mêmes étapes que précédemment.

[CAUTION]
====
L'identifiant est utilisé comme clé unique d'une liaison métrique. La modification de l'identifiant créera une nouvelle liaison métrique au lieu de mettre à jour la liaison existante.
====


La commande `sts settings` a plus d'options, par exemple elle peut lister toutes les liaisons métriques :

[,bash]
----
sts settings list --type MetricBinding
----

Enfin, pour supprimer une liaison métrique, utilisez

[,bash]
----
sts settings delete --ids <id>
----

Le `<id>` de cette commande n'est pas l'identifiant mais le numéro de la colonne `Id` de la sortie `sts settings list`.

[NOTE]
====
La méthode de travail recommandée consiste à stocker les liaisons métriques (et toute autre ressource personnalisée créée dans SUSE Observability) sous forme de fichiers YAML dans un dépôt Git. À partir de là, les modifications peuvent être appliquées manuellement ou être entièrement automatisées à l'aide de l'interface CLI de SUSE Observability dans un système CI/CD tel que les actions GitHub ou les pipelines GitLab.
====


== Autres options

=== Plus d'une série temporelle dans un graphique

[NOTE]
====
Il n'y a qu'une seule unité pour une reliure métrique (elle est reportée sur l'axe des ordonnées du graphique). Par conséquent, vous ne devez combiner que les requêtes qui produisent des séries temporelles avec la même unité dans une seule liaison métrique. Il est parfois possible de convertir l'unité. Par exemple, l'utilisation de l'unité centrale peut être indiquée en milli-cores ou en cœurs. Les milli-cores peuvent être convertis en cœurs en les multipliant par 1000, comme dans le cas suivant : `(<original-query>) * 1000`.
====


Il y a deux façons d'obtenir plus d'une série temporelle dans une seule liaison métrique et donc dans un seul graphique :

. Écrire une requête PromQL qui renvoie plusieurs séries temporelles pour un seul composant.
. Ajouter des requêtes PromQL à la liaison métrique

Pour la première option, un exemple est donné dans la xref:/use/metrics/k8s-add-charts.adoc#_using_metric_labels_in_aliases[section suivante]. La deuxième option peut s'avérer utile pour comparer des mesures connexes. Quelques cas d'utilisation typiques :

* Comparaison entre le nombre total de répliques et les répliques souhaitées et disponibles
* Utilisation des ressources : limites, demandes et utilisation dans un seul graphique

Pour ajouter d'autres requêtes à une liaison métrique, il suffit de répéter les xref:/use/metrics/k8s-add-charts.adoc#_steps[étapes] 3 et 4 et d'ajouter la requête en tant qu'entrée supplémentaire dans la liste des requêtes. En ce qui concerne le nombre de répliques de déploiement, plusieurs mesures connexes peuvent être incluses dans le même graphique :

----
nodes:
- _type: MetricBinding
  chartType: line
  enabled: true
  tags: {}
  unit: short
  name: Replica counts
  priority: MEDIUM
  identifier: urn:custom:metric-binding:my-deployment-replica-counts
  queries:
    - expression: max_over_time(kubernetes_state_deployment_replicas{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", deployment="${name}"}[${__interval}])
      alias: Total replicas
    - expression: max_over_time(kubernetes_state_deployment_replicas_available{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Available - ${cluster_name} - ${namespace} - ${deployment}
    - expression: max_over_time(kubernetes_state_deployment_replicas_unavailable{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Unavailable - ${cluster_name} - ${namespace} - ${deployment}
    - expression: min_over_time(kubernetes_state_deployment_replicas_desired{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}",  deployment="${name}"}[${__interval}])
      alias: Desired - ${cluster_name} - ${namespace} - ${deployment}
  scope: type = "deployment" and label = "stackpack:kubernetes"
----

image::k8s/k8s-replica-counts-multiple-timeseries.png[Liaison de métriques avec plusieurs métriques]

=== Utilisation d'étiquettes métriques dans les alias

Lorsqu'une requête unique renvoie plusieurs séries temporelles par composant, cela se traduit par plusieurs lignes dans le graphique. Mais dans la légende, ils utiliseront tous le même alias. Pour pouvoir voir la différence entre les différentes séries temporelles, l'alias peut inclure des références aux étiquettes métriques à l'aide de la syntaxe `${label}`. Par exemple, voici une liaison de métrique pour la métrique "Container restarts" sur un pod, notez qu'un pod peut avoir plusieurs conteneurs :

----
type: MetricBinding
chartType: line
enabled: true
id: -1
identifier: urn:custom:metric-binding:my-pod-restart-count
name: Container restarts
priority: MEDIUM
queries:
- alias: Restarts - ${container}
  expression: max by (cluster_name, namespace, pod_name, container) (kubernetes_state_container_restarts{cluster_name="${tags.cluster-name}", namespace="${tags.namespace}", pod_name="${name}"})
scope: (label = "stackpack:kubernetes" and type = "pod")
unit: short
----

Notez que `alias` fait référence à l'étiquette `container` de la métrique. Assurez-vous que l'étiquette est présente dans le résultat de la requête. Si l'étiquette n'est pas présente, le site `${container}` sera affiché en tant que texte littéral pour faciliter le dépannage.

=== Modèles

Chaque composant peut être associé à diverses technologies ou protocoles tels que les k8, les réseaux, les environnements d'exécution (par exemple, JVM), les protocoles (HTTP, AMQP), etc.
Par conséquent, une multitude de mesures différentes peuvent être affichées pour chaque composant. Pour une meilleure lisibilité, SUSE Observability peut organiser ces graphiques sous forme d'onglets et de sections.
Pour afficher un graphique (`MetricBinding`) dans un onglet ou une section spécifique, vous devez configurer la propriété de mise en page.
Tout MetricsBinding dont la présentation n'est pas spécifiée sera affiché dans un onglet et une section nommés `Other`.

Voici un exemple de configuration :

----
layout:
  metricPerspective:
    tab: Kubernetes Pod
    section: Performance
    weight: 2
  componentSummary:
    weight: 2
----

Domaines :

* `layout.metricPerspective` - Définit les mesures à afficher sur `Metrics Perspective`. Les mesures sont regroupées en onglets puis en sections.
* `layout.metricPerspective.tab` - Nom de l'onglet. Les onglets sont classés par ordre alphabétique.
* `layout.metricPerspective.section` - Nom de la section. Les sections sont classées par ordre alphabétique.
* `layout.metricPerspective.weight` - Les mesures d'une section sont triées en premier lieu par poids (ordre croissant) et en second lieu par nom (ordre alphabétique).
* `layout.componentSummary` - Spécifie les métriques à afficher dans la barre latérale `Components details` lors de la sélection d'un composant. Les graphiques n'apparaissent que lorsque cette propriété est définie.
* `layout.componentSummary.weight` - Il s'agit du poids de la carte. Les graphiques sont triés par ordre croissant de poids et affichent les 3 premiers graphiques.
